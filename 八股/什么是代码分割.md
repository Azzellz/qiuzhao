代码分割（Code Splitting）是一种**按需加载**技术：  
把原本“一整块”打包产物拆成**多个更小的 bundle（或 chunk）**，在运行时**按路由、组件、功能或懒加载条件**再动态拉取，从而减少首屏下载量、提升加载性能。

---

### 1. 为什么需要代码分割？
| 问题 | 传统单文件 bundle | 代码分割后 |
| --- | --- | --- |
| 首屏体积 | 所有逻辑一次性下载 | 只下载当前需要的 chunk |
| 缓存命中率 | 一行改动 → 整包失效 | 改动仅影响对应 chunk |
| 并行加载 | 单线程串行 | HTTP/2 多路复用并行 |
| 用户体验 | 白屏时间长 | 首屏秒开，剩余功能渐进增强 |

---

### 2. 三种主流分割维度
1. **入口（Entry）分割**  
   Webpack/Rollup 里配置多入口，每个入口生成独立 bundle。  
   适用：多页面（MPA）、微前端子应用。

2. **动态导入（Dynamic Import）**  
   使用 `import()` 语法让打包工具自动生成懒加载 chunk。  
   ```js
   // 点击按钮时再加载图表库
   button.onclick = async () => {
     const { renderChart } = await import('./chart.js');
     renderChart();
   };
   ```

3. **第三方库分割（Vendor Splitting）**  
   把 `node_modules` 中变化频率低的库拆成 `vendor.[hash].js`，业务代码拆成 `app.[hash].js`。  
   Webpack 配置示例：
   ```js
   optimization: {
     splitChunks: {
       chunks: 'all',
       cacheGroups: {
         vendor: {
           test: /[\\/]node_modules[\\/]/,
           name: 'vendors',
           priority: 10,
         },
       },
     },
   }
   ```

---

### 3. 运行时加载流程（以浏览器为例）
1. 请求 HTML → 2. 加载主入口 JS（如 `main.[hash].js`）→  
3. 运行到 `import('./chunk.js')` → 4. 浏览器异步拉取 chunk →  
5. 解析并执行 → 6. 渲染对应功能/路由。

---

### 4. 框架级封装
| 框架 | 代码分割方案 |
| --- | --- |
| React | `React.lazy(() => import('./Page'))` + `<Suspense>` |
| Vue 3 | `defineAsyncComponent(() => import('./Comp'))` |
| Angular | `loadChildren: () => import('./admin.module').then(m => m.AdminModule)` |
| Next.js | 自动按页面路由分割；`next/dynamic` 做组件级懒加载 |
| Vite | 与 Rollup 同机制，支持魔法注释 `/* webpackChunkName: "foo" */` |

---

### 5. 一句话总结
> 代码分割 = **“把大 bundle 切小 + 按需加载”**，让**首屏只下必要的代码**，其余功能**用时再取**。
