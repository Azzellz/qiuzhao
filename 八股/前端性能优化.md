前端性能优化是一个系统工程，涉及网络、资源加载、渲染、运行时等多个环节。以下从核心原理到实战落地，为你系统梳理前端性能优化的全链路方案：

---

### **一、网络层优化：减少传输成本**
1. **压缩与格式优化**
   - **资源压缩**：启用Gzip/Brotli压缩（文本资源可减小70%+）。
   - **图片优化**：
     - 使用WebP/AVIF格式（比JPEG减小30%-50%）。
     - 响应式图片：`<img srcset>`根据屏幕密度加载不同尺寸。
     - 懒加载：原生`loading="lazy"`或Intersection Observer API。
   - **代码压缩**：Webpack的`TerserPlugin`压缩JS/CSS，Tree Shaking删除未使用代码。

2. **缓存策略**
   - **HTTP缓存**：
     - 强缓存：`Cache-Control: max-age=31536000`（静态资源）。
     - 协商缓存：`ETag` + `If-None-Match`（动态内容）。
   - **Service Worker缓存**：
     - 预缓存静态资源（Workbox插件）。
     - 运行时缓存API响应（Stale-While-Revalidate策略）。

3. **减少请求数**
   - **资源合并**：HTTP/2多路复用下可适度拆分，但HTTP/1.1需合并。
   - **雪碧图**：将小图标合并为SVG雪碧图（如`svg-sprite-loader`）。

---

### **二、渲染层优化：加速页面呈现**
1. **关键渲染路径优化**
   - **减少阻塞**：
     - JS：使用`async/defer`避免阻塞HTML解析。
     - CSS：关键CSS内联（`Critical CSS`），非关键CSS异步加载（`rel="preload"`）。
   - **预加载关键资源**：
     ```html
     <link rel="preload" href="main.css" as="style">
     <link rel="dns-prefetch" href="//api.example.com">
     ```

2. **减少重排与重绘**
   - **CSS优化**：
     - 避免`table-layout`、`position: fixed`等触发重排的属性。
     - 使用`transform`和`opacity`实现动画（仅触发合成层更新）。
   - **DOM操作**：
     - 批量修改DOM（`DocumentFragment`或离线DOM）。
     - 使用`requestAnimationFrame`优化动画帧。

3. **虚拟化与分页**
   - **长列表优化**：React Virtualized、Vue Virtual Scroller仅渲染可见区域。
   - **分页加载**：无限滚动+Intersection Observer触发加载。

---

### **三、运行时优化：提升交互流畅度**
1. **JavaScript性能**
   - **代码分割**：Webpack的`SplitChunksPlugin`拆分首屏/非首屏代码。
   - **懒加载路由**：React.lazy(() => import('./Detail'))。
   - **减少主线程阻塞**：
     - Web Workers处理计算密集型任务（如加密、排序）。
     - 时间切片：React 18的`startTransition`标记非紧急更新。

2. **内存管理**
   - 避免内存泄漏：
     - 解绑事件监听器（`removeEventListener`）。
     - 清除定时器（`clearInterval`）。
     - 弱引用：`WeakMap`/`WeakSet`存储DOM节点。

3. **性能监控**
   - **核心指标**：
     - **FCP（首次内容绘制）**：<1.8秒为优秀。
     - **LCP（最大内容绘制）**：<2.5秒为优秀。
     - **CLS（累积布局偏移）**：<0.1为优秀。
   - **工具**：
     - Lighthouse：自动化性能审计。
     - Web Vitals：实时监控（`web-vitals`库）。
     - Performance API：自定义埋点（`performance.mark()`）。

---

### **四、框架级优化（React/Vue为例）**
1. **React优化**
   - **避免重复渲染**：
     - `React.memo` + `useMemo`缓存组件/计算结果。
     - `useCallback`缓存函数引用。
   - **状态管理**：Zustand/Jotai替代Redux减少全局更新。
   - **并发特性**：React 18的`useTransition`/`useDeferredValue`。

2. **Vue优化**
   - **响应式优化**：
     - 避免在`v-for`中绑定复杂表达式。
     - 使用`shallowRef`减少深层响应式开销。
   - **异步组件**：`defineAsyncComponent`按需加载。

---

### **五、前沿技术**
1. **边缘计算**：Cloudflare Workers处理动态内容，减少回源延迟。
2. **微前端**：Module Federation共享依赖，避免重复加载。
3. **预渲染**：Next.js的SSG/ISR或React 18的Streaming SSR。

---

### **六、实战案例：电商首页优化**
1. **资源优化**：
   - 图片：WebP格式+懒加载+CDN（如阿里云OSS）。
   - 关键CSS内联，其余异步加载。
2. **渲染优化**：
   - 骨架屏替代白屏（如`react-loading-skeleton`）。
   - 无限滚动商品列表（Intersection Observer）。
3. **性能监控**：
   - 接入Sentry监控JS错误，Lighthouse CI集成到GitHub Actions。

---

### **检查清单（Checklist）**
- [ ] 启用Brotli压缩和HTTP/2。
- [ ] 图片是否全部使用WebP+懒加载？
- [ ] 关键资源是否预加载？
- [ ] 是否拆分首屏与非首屏JS？
- [ ] CLS是否<0.1（避免布局抖动）？

通过以上全链路优化，通常可将LCP从4秒降至1.5秒以内，TTI（可交互时间）减少50%+。实际优化需结合Lighthouse报告和业务场景针对性调整。